# 6 类文件结构

代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。

## 6.1 概述

曾记得在第一堂计算机程序课上老师就讲过：“计算机只认识0和1，所以我们写的程序需要被编译器翻译成由0和1构成的二进制格式才能被计算机执行。”十多年过去了，今天的计算机仍然只能识别0 和1，但由于最近十年内虚拟机以及大量建立在虚拟机之上的程序语言如雨后春笋般出现并蓬勃发展， 把我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语 言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。

## 6.2 无关性的基石
如果全世界所有计算机的指令集就只有x86一种， 操作系统就只有Windows一种， 那也许就不会有Java语言的出现。 Java在刚刚诞生之时曾经提出过一个非常著名的宣传口号“一次编写， 到处运行（Write Once， Run Anywhere） ”， 这句话充分表达了当时软件开发人员对冲破平台界限的渴求。 在每时每刻都充满竞争的IT业界， 不可能只有Wintel[1]存在， 我们也不希望出现只有Wintel而没有竞争者的世界， 各种不同的硬件体系结构、 各种不同的操作系统肯定将会长期并存发展。 “与平台无关”的理想最终只有实现在操作系统以上的应用层： Oracle公司以及其他虚拟机发行商发布过许多可以运行在各种不同硬件平台和操作系统上的Java虚拟机， 这些虚拟机都可以载入和执行同一种平台无关的字节码， 从而实现了程序的“一次编写， 到处运行”。

各种不同平台的Java虚拟机， 以及所有平台都统一支持的程序存储格式——字节码（Byte Code）是构成平台无关性的基石， 但本节标题中笔者刻意省略了“平台”二字， 那是因为笔者注意到虚拟机的另外一种中立特性——语言无关性正在越来越被开发者所重视。 直到今天， 或许还有相当一部分程序员认为Java虚拟机执行Java程序是一件理所当然和天经地义的事情。 但在Java技术发展之初， 设计者们就曾经考虑过并实现了让其他语言运行在Java虚拟机之上的可能性， 他们在发布规范文档的时候， 也刻意把Java的规范拆分成了《Java语言规范》 （The Java Language Specification） 及《Java虚拟机规范》（The Java Virtual Machine Specification） 两部分。 并且早在1997年发表的第一版《Java虚拟机规范》 中就曾经承诺过： “在未来， 我们会对Java虚拟机进行适当的扩展， 以便更好地支持其他语言运行于Java虚拟机之上”（In the future， we will consider bounded extensions to the Java virtual machine to provide better support for other languages） 。 Java虚拟机发展到今天， 尤其是在2018年， 基于HotSpot扩展而来的GraalVM公开之后， 当年的虚拟机设计者们已经基本兑现了这个承诺。

时至今日， 商业企业和开源机构已经在Java语言之外发展出一大批运行在Java虚拟机之上的语言，如Kotlin、 Clojure、 Groovy、 JRuby、 JPython、 Scala等。 相比起基数庞大的Java程序员群体， 使用过这些语言的开发者可能还不是特别多， 但是听说过的人肯定已经不少， 随着时间的推移， 谁能保证日后Java虚拟机在语言无关性上的优势不会赶上甚至超越它在平台无关性上的优势呢？

实现语言无关性的基础仍然是虚拟机和字节码存储格式。 Java虚拟机不与包括Java语言在内的任何程序语言绑定， 它只与“Class文件”这种特定的二进制文件格式所关联， Class文件中包含了Java虚拟机指令集、 符号表以及若干其他辅助信息。 基于安全方面的考虑， 《Java虚拟机规范》 中要求在Class文件必须应用许多强制性的语法和结构化约束， 但图灵完备的字节码格式， 保证了任意一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。 作为一个通用的、 与机器无关的执行平台， 任何其他语言的实现者都可以将Java虚拟机作为他们语言的运行基础， 以Class文件作为他们产品的交付媒介。 例如， 使用Java编译器可以把Java代码编译为存储字节码的Class文件， 使用JRuby等其他语言的编译器一样可以把它们的源程序代码编译成Class文件。 虚拟机丝毫不关心Class的来源是什么语言， 它与程序语言之间的关系如图6-1所示。

Java语言中的各种语法、 关键字、 常量变量和运算符号的语义最终都会由多条字节码指令组合来表达， 这决定了字节码指令所能提供的语言描述能力必须比Java语言本身更加强大才行。 因此， 有一些Java语言本身无法有效支持的语言特性并不代表在字节码中也无法有效表达出来， 这为其他程序语言实现一些有别于Java的语言特性提供了发挥空间。  

## 6.3 Class类文件的结构
解析Class文件的数据结构是本章的最主要内容。 笔者曾经在前言中阐述过本书的写作风格： 力求在保证逻辑准确的前提下， 用尽量通俗的语言和案例去讲述虚拟机中与开发关系最为密切的内容。 但是， 对文件格式、 结构方面的学习， 有点类似于“读字典”， 读者阅读本章时， 大概会不可避免地感到比较枯燥， 但这部分内容又是Java虚拟机的重要基础之一， 是了解虚拟机的必经之路， 如果想比较深入地学习虚拟机相关知识， 这部分是无法回避的。

Java技术能够一直保持着非常良好的向后兼容性，Class文件结构的稳定功不可没，任何一门程序语言能够获得商业上的成功， 都不可能去做升级版本后， 旧版本编译的产品就不再能够运行这种事情。 本章所讲述的关于Class文件结构的内容， 绝大部分都是在第一版的《Java虚拟机规范》 （1997年发布， 对应于JDK 1.2时代的Java虚拟机） 中就已经定义好的， 内容虽然古老， 但时至今日， Java发展经历了十余个大版本、 无数小更新， 那时定义的Class文件格式的各项细节几乎没有出现任何改变。 尽管不同版本的《Java虚拟机规范》 对Class文件格式进行了几次更新， 但基本上只是在原有结构基础上新增内容、 扩充功能， 并未对已定义的内容做出修改。

> 注意 任何一个Class文件都对应着唯一的一个类或接口的定义信息[1]， 但是反过来说， 类或接口并不一定都得定义在文件里（譬如类或接口也可以动态生成， 直接送入类加载器中） 。 本章中，笔者只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”， 实际上它完全不需要以磁盘文件的形式存在。

Class文件是一组以8个字节为基础单位的二进制流， 各个数据项目严格按照顺序紧凑地排列在文件之中， 中间没有添加任何分隔符， 这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据， 没有空隙存在。 当遇到需要占用8个字节以上空间的数据项时， 则会按照高位在前[2]的方式分割成若干个8个字节进行存储。

根据《Java虚拟机规范》 的规定， Class文件格式采用一种类似于C语言结构体的伪结构来存储数据， 这种伪结构中只有两种数据类型： “无符号数”和“表”。 后面的解析都要以这两种数据类型为基础， 所以这里笔者必须先解释清楚这两个概念。

- 无符号数属于基本的数据类型， 以u1、 u2、 u4、 u8来分别代表1个字节、 2个字节、 4个字节和8个字节的无符号数， 无符号数可以用来描述数字、 索引引用、 数量值或者按照UTF-8编码构成字符串值。
- 表是由多个无符号数或者其他表作为数据项构成的复合数据类型， 为了便于区分， 所有表的命名都习惯性地以“_info”结尾。 表用于描述有层次关系的复合结构的数据， 整个Class文件本质上也可以视作是一张表， 这张表由表6-1所示的数据项按严格顺序排列构成。  

**表略**

无论是无符号数还是表， 当需要描述同一类型但数量不定的多个数据时， 经常会使用一个前置的容量计数器加若干个连续的数据项的形式， 这时候称这一系列连续的某一类型的数据为某一类型的“集合”。

本节结束之前， 笔者需要再强调一次， Class的结构不像XML等描述语言， 由于它没有任何分隔符号， 所以在表6-1中的数据项， 无论是顺序还是数量， 甚至于数据存储的字节序（Byte Ordering， Class文件中字节序为Big-Endian） 这样的细节， 都是被严格限定的， 哪个字节代表什么含义， 长度是多少，先后顺序如何， 全部都不允许改变。 接下来， 我们将一起看看这个表中各个数据项的具体含义。

[1] 其实也有反例， 譬如package-info.class、 module-info.class这些文件就属于完全描述性的。

[2] 这种顺序称为“Big-Endian”， 具体顺序是指按高位字节在地址最低位， 最低字节在地址最高位来存储数据， 它是SPARC、 PowerPC等处理器的默认多字节存储顺序， 而x86等处理器则是使用了相反的“Little-Endian”顺序来存储数据。  