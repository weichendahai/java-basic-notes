# 1.面对对象的特性
### 1.封装性
### 2.继承性
### 3.多态性

# 2.类
## 2.1类声明
类的第一个字符不能是数字，类名使用拉丁字母时，首字母应该使用大写字母，由多个单词复合而成时，每个单词的首字母大写。

## 2.2类体
类体分为两种：一部份是变量的声明，另一部分是方法的定义
### 1.变量的声明
### 2.方法
例如：
```
Class Lader{
	float above;
	float bottom;
	Float height;
	float computer{
	area=(above+bottom)*height/2;
	Return area;
	}
}
```
## 2.3成员变量
变量声明部分声明的变量被称作域变量或成员变量。
### 1.成员变量的类型
### 2.成员变量的有效范围
### 3.编程风格

## 2.4方法
### 1.方法声明
### 2.方法体
### 3.区分成员变量和局部变量
## 2.5需要注意的问题
在申明成员变量的时候可以赋值  
但是不可以这样：
```
class A{
	int a;
	a=5;
}
```
# 3.构造方法与对象的创建
类是面向对象语言中最重要的一种数据类型，可以用它来声明变量在面向对象语言中，用类声明的变量叫对象。  
和基本数据类型不同，在类声明对象后，还必须创建对象，即为声明的对象分配变量，当使用一个类创建一个对象时，也称给出了这个类的一个实例，通俗的来讲，类是创建对象的模板，没有类就没有对象。  
构造方法和对象的创建密切相关。
## 3.1构造方法
一般来说，如果没有编写构造方法，系统会默认创建一个构造方法，该默认的构造方法时无参数的。  
比如这样：
```
Lader(){
}
```
如果定义里定义了一个或多个构造方法，那么Java默认不提供默认的构造方法，例如，下面的Point有两个构造方法
```
class Point{
	int x,y;
	Point(){
		x=1;
		y=2;
	}
	Point(int a,int b){
		x=a;
		y=b;
	}
}
```
## 3.2创建对象
### 1.对象的声明
```
Lader lader;
```
### 2.为创建的对象分配变量
使用new运算符和类的构造方法为声明的对象分配变量。
### 3.对象的内存模型
## 3.3使用对象
抽象的目的是产生类，而类的目的是创建具有属性和功能的对象。对象不仅可以操作自己的变量改变状态，还能调用类中的方法产生一定的行为。
### 1.对象操作自己的变量（改变属性的值）
```
对象.变量
```
### 2.对象调用类中的方法（体现对象的功能）
```
对象.方法
```
### 3.体现封装
当对象调用方法时，方法中出现的成员变量就是指分配给该对象的变量。在讲述类的时候我们讲过类中的方法可以操作成员变量。当对象调用方法时，方法中出现的成员变量就是指分配给该对象的变量。
```
class XiyoujiRenwu{
	float height,weight;  
	String head,ear,hand,foot,nouth;
	void speak(Strings) {
		head="歪着头”;
		Systen.out.printin(s);
	}
}

public class Exanple5 3 {
	public static void main(String args[]){
		XiyoujiRenwu zhubajie,sunwukong;  //声明对象
		zhubajie = new XiyoujiRenwu();  //为对象分配变量
		sunwukong = new Xiyouj iRenwu();
		zhubajie.height= 1.80f;  //对象给自己的变量赋值
		zhubajie.head="大头";
		zhubajie.ear="一双大耳朵";
		sunwukong.height= 1.62f;  //对象给自己的变量赋值
		sunwukong.weight= 1000f;
		sunwukong.head="秀发飘飘";
		System.out.println("zhubajie的身高:”+ zhubajie.height);
		System.out.printIn(" zhubajie的头:”+ zhubajie.head);
		System.out.println("sunwukong的重量:" + sunnukong.weight);
		System.out.println("sunwukong的头:”+ sunmukong. head);
		zhubajie.speak("俺老猪我想娶媳妇");  //对象调用方法
		Systen.out.println("zhubajie现在的头:”+ zhubajie.head);
		sunmukong.speak("老孙我重1000斤，我想骗八戒背我");  //对象调用方法
		Systen.out.println(" sunwnukong现在的头:”+ sunwukong.head);
	}
}
```
我们知道:类中的方法可以操作成员变量，当对象调用该方法时，方法中出现的成员变量就是指该对象的成员变量。在例5.3中，当对象zhubajie调用过方法speak之后，就将自己的头改成歪着头，后一个对象调用方法后也是这样。

## 3.4对象的引用和引申
类是体现封装的一种数据结构，类声明的变量称作对象，对象中负责存放引用，以确保对象可以操作分配给该对象的变量以及调用类中的方法。分配给对象的变量习惯的称作对象的实体。
### 1.避免使用空对象
没有实体的对象称作空对象，空对象不能使用。
### 2.垃圾收集
例如
```
Point p1=new Point(5,15);
Point p2=new Point(8,18);
P1=p2;
```
这个时候输出p1.x是8而不是5，与C++不同，这里的类有构方法，没有析构方法，JAVA默认有垃圾收集机制。
# 4.参数传值
方法中最重要的部分之一就是方法的参数，参数属于局部变量，当对象调用方法时，参数被分配到内存空间，并要求调用者向参数传递值，即方法被调用时，参数变量必须有具体的值。
## 4.1传值机制
Java中，方法所有的参数都是传值的，也就是说，方法中参数变量的值是调用者指定值的复制。
## 4.2基本数据类型参数的传值
```
package test1;
import java.util.Scanner;

class Circle{
	double radius,area;
	Circle(){
}
	Circle(double r){
		radius=r;
	}
	void setRadius(double r) {
		if(r>0) {
			radius=r;
		}
	}
	double getRadius() {
		return radius;
	}
	double getArea() {
		area=3.14*radius*radius;
		return area;
	}
}


class Circular{
	Circle bottom;
	double height;
	Circular(Circle c,double h){
		bottom=c;
		height=h;
	}
	double getVolme() {
		return bottom.getArea()*height/3.0;
	}
	double getBottomRadius() {
		return bottom.getRadius();
	}
	public void setBottomRadius(double r) {
		bottom.setRadius(r);
	}
}


public class exercise {
	public static void main(String args[]) {
		Circle circle=new Circle(10);
		System.out.println("main方法中circle的引用："+circle);
		System.out.println("main方法中circle的半径："+circle.getRadius());
		Circular circular=new Circular(circle,20);
		System.out.println("circular圆锥的bottom的引用："+circular.bottom);
		System.out.println("圆锥的bottom的半径："+circular.getVolme());
		System.out.println("圆锥的体积："+circular.getVolme());
		double r=8888;
		System.out.println("圆锥更改底园bottom的半径："+r);
		circular.setBottomRadius(r);
		System.out.println("圆锥的bottom的半径："+circular.getBottomRadius());
		System.out.println("圆锥的体积："+circular.getVolme());
		System.out.println("main方法中circle的半径"+circle.getRadius());
		System.out.println("main方法中circle的引用将会发生变化");
		circle=new Circle(1000);
		System.out.println("现在mian方法中circle的引用："+circle);
		System.out.println("main方法中circle的引用："+circle.getRadius());
		System.out.println("但是不影响circular圆锥的bottom的引用");
		System.out.println("circular圆锥的bottom引用"+circular.bottom);
		System.out.println("圆锥的bottom的半径："+circular.getBottomRadius());
	}
}
```
运行结果
```
```
# 5.对象的组合

# 6.实例成员与类成员
## 6.1实例变量和类变量的声明
类体中包括变量的声明和方法的定义  
成员变量又分为实例变量和类变量在声明成员变量时，用关键字static修饰的称作类变量（也被称为静态变量）
```
Class Dog{
	float x;
	static int y;
}
```
## 6.2实例变量和类变量的区别
### 1.不同对象的实例变量互不相同
分配给不同的对象的实例变量占有不同的内存空间。
### 2.所有对象共享类变量
### 3.可以通过类名直接访问类变量
改变其中一个对象的类变量就同时改变了其他对象的这个类变量。

## 6.3实例方法和类方法的定义
可以参照实例变量和类变量的声明

## 6.4实例方法和类方法的区别
### 1.对象调用实例方法
当类的字节码文件加载到内存时，类的实例方法不会被分配入口地址，只有该类创建对象后，类中的实例方法才分配入口地址。
需要注意的是，当我们创建第一个对象时，类中的实例方法就分配了入口地址，当再创建对象时，不在分配入口地址，也就是说，方法的入口地址被所有对象共享，当所有对象都不存在时，方法的入口地址才会被取消。
### 2.类名调用类方法
对于类中的类方法，在该类被加载到内存时，就分配了相应的入口地址，从而类方法不仅可以被类创建的任何对象调用执行，也可以被类名调用执行，类方法的入口地址直到程序退出才被取消。
和实例方法不同的是，类方法不可以操作实例变量，这是因为在类创建对象之前，实例成员变量还没有分配内存。
```
class Village{
	static int treeAmount;
	int peopleNumber;
	String name;
	Village(String s){
		name=s;
	}
	void treePlanting(int n) {
		treeAmount=n+treeAmount;
		System.out.println(name+"植树"+n+"棵");
	}
	void feelTree(int n) {
		if(treeAmount-n>0){
			treeAmount=treeAmount-n;
			System.out.println(name+"伐木"+n+"棵");
		}
		else {
			System.out.println("无树木可伐");
		}
	}
	static int loolTreeAmount() {
		return treeAmount;
	}
	void addPeopleNumber(int n) {
		peopleNumber=n+peopleNumber;
		System.out.println(name+"增加了"+n+"人");
	}
}

public class exercise{
	public static void main(String args[]) {
		Village zhaoZhuang,maJiaZhi;
		zhaoZhuang=new Village("赵庄");
		maJiaZhi=new Village("马家河子");
		zhaoZhuang.peopleNumber=100;
		maJiaZhi.peopleNumber=150;
		Village.treeAmount=200;
		int lefttree=Village.treeAmount;
		System.out.println("森林中有"+lefttree+"棵树");
		zhaoZhuang.treePlanting(50);
		maJiaZhi.treePlanting(100);
		System.out.println("森林中有"+Village.treeAmount+"棵树");
	}
}
```
# 7 方法重载与多态
Java中存在两种多态，重载和重写,重写是与继承有关的多态，下一章讨论  

方法重载的意思是一个类中可以有多个方法具有相同的名字，但这些方法的参数必须不相同，即或者是参数的个数不相同，或者是参数的类型不相同。  

方法的返回类型和参数的名字不参与比较，也就是说如果两个方法的名字相同，即使类型不同，也必须保证参数不同。
# 8 this关键字
this是Java中的一个关键字，表示某个对象。  
this可以出现在实例方法和构造方法中，但是不可以出现在类方法中。
## 8.1在构造方法中使用this
```
public class People{
	int leg,hand;
	String name;
	People(String s){
		name=s;
		this.init();//可以省略this，写成init()
	}
	void init() {
		leg=2;
		hand=2;
		System.out.println(name+"有"+hand+"只手"+leg+"只脚");
	}
	public static void main(String args[]) {
		People boshi=new People("布什");
	}
}
```
## 8.2在实例方法中使用this
实例方法必须通过对象来调用，不能通过类名来调用；当this出现在实例方法中，代表正在调用该方法的当前对象。  

实例方法可以操作类的成员变量，当实例成员变量在实例方法中出现时，默认的格式是：
```
This.成员变量
```
而static成员变量在实例方法中出现时，默认的格式是：
```
类名.成员变量
```
如：
```
clsaa A{
	int a;
	static int y;
	void f(){
	this.x=100;
	A.y=200;
	}
}
```
当实例成员变量的名字和局部变量的名字相同时，成员变量前面的this.或者类名.就不可省略  

我们知道类的实例方法能调用类的其他方法，对于实例方法的调用的默认格式是：
```
this.方法
```
但是对于类方法调用的默认格式是：
```
类名.方法；
```
例如：
```
class B{
	void f(){
		this.g();
		B.h();
	}
	void g(){
		System.out.println("ok");
	}
	static void h(){
		System.out.println("hello");
	}
}
```
在上述B类方法中出现了this，this代表调用方法f的当前对象，所以，方法f的方法体中this.g()就是当前对象调用方法g，也就是说，当某个对象调用方法f的过程中，又调用了方法g。由于这种逻辑关系非常明确，一个实例方法调用另一个方法时可以省略方法名字前面的"this."或"类名."  
例如：
```
class B{
	void f(){
		.g();
		h();
	}
	void g(){
		System.out.println("ok");
	}
	static void h()){
		System.out.println("hello");
	}
}
```
this不能出现在类方法中，这是因为，类方法可以通过类名直接调用，这时，可能还没有任何对象诞生。
# 11 访问权限
## 11.1什么是访问权限
需要说明的是，在编写类时，类中的实例方法总是可以操作该类中的实例变量；类方法总是可以操作该类中的类变量，与访问限制没有关系。
## 11.2私有变量和私有方法
使用关键字private修饰的成员变量和方法称为私有变量和私有方法。如：
```
class Tom{
	private floata weight;
	private float f(float a,float b){
		return a+b;
	}
}
```
当在另外一个类Tom创建了一个对象后，该对象不能访问自己的私有变量和私有方法；
```
class Jerry{
	void g(){
		Tom cat=new Tom();
		cat.weight=23f;//非法
		float sum=cat.f(3,4);//非法
	}
}
```
如果Tom中的某个成员时私有类变量(静态成员变量)那么在另外一个类中，也不可以通过类名Tom来操作这个私有类变量，如果Tom类中的某个方法时私有的类方法，那么在另一个类中，也不可以用类名Tom来调用这个私有的类方法；
## 11.3共有变量和共有方法
用public修饰的成员变量和方法被称为共有变量和共有方法  
同理，在另一个类中，可以通过类名Tom来操作Tom的这个成员变量。【或者类方法】
## 11.4友好变量和友好方法
不用private，public，protected修饰符的成员变量和方法称为友好变量和友好方法。
## 11.5受保护的成员变量和方法
## 11.6 public类与友好类
类如：
```
public class A{
···
}
```
不能用protected和private修饰类
