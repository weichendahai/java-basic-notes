Java基础知识笔记-附2-异常，断言和日志

在理想状态下，用户输入数据的格式永远都是正确的， 选择打开的文件也一定存在，并且永远不会出现 bug。迄今为止，本书呈现给大家的代码似乎都处在这样一个理想境界中。 然而，在现实世界中却充满了不良的数据和带有问题的代码，现在是讨论 Java 程序设计语育 处理这些问题的机制的时候了。 

人们在遇到错误时会感觉不爽。如果一个用户在运行程序期间，由于程序的错误或一些外部环境的影响造成用户数据的丢失，用户就有可能不再使用这个程序了， 为了避免这类事情的发生， 至少应该做到以下几点： 

- 向用户通告错误； 
- 保存所有的工作结果；
- 允许用户以妥善的形式退出程序。

对于异常情况， 例如，可能造成程序崩溃的错误输入，Java使用一种称为异常处理 ( exception handing) 的错误捕获机制处理。Java中的异常处理与 C++ 或Delphi中的异常处理十分类似。本章的第1部分先介绍Java的异常。

在测试期间，需要进行大量的检测以验证程序操作的正确性。 然而，这些检测可能非常耗 时，在测试完成后也不必保留它们，因此，可以将这些检测删掉， 并在其他测试需要时将它们粘贴回来，这是一件很乏味的事情。本章的第2部分将介绍如何使用断言来有选择地启用检测。 

当程序出现错误时，并不总是能够与用户或终端进行沟通。此时，可能希望记录下出现的问题，以备日后进行分析。本章的第3部分将讨论标准Java日志框架。

## 1 处理错误

假设在一个Java程序运行期间出现了一个错误。这个错误可能是由于文件包含了错误信息，或者网络连接出现问题造成的，也有可能是因为使用无效的数组下标， 或者试图使用 一个没有被赋值的对象引用而造成的。用户期望在出现错误时， 程序能够采用一些理智的行为。如果由于出现错误而使得某些操作没有完成， 程序应该：

- 返回到一种安全状态，并能够让用户执行一些其他的命令；或者
- 允许用户保存所有操作的结果，并以妥善的方式终止程序

要做到这些并不是一件很容易的事情。其原因是检测（或引发）错误条件的代码通常离那些能够让数据恢复到安全状态， 或者能够保存用户的操作结果， 并正常地退出程序的代码 很远。异常处理的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器。为了能够在程序中处理异常情况， 必须研究程序中可能会出现的错误和问题， 以及哪类问题需要关注。 

1. 用户输入错误

   除了那些不可避免的键盘输入错误外, 有些用户喜欢各行其是，不遵守程序的要求。例 如，假设有一个用户请求连接一个URL，而语法却不正确。在程序代码中应该对此进行检查，如果没有检査，网络层就会给出警告。 

2. 设备错误

   硬件并不总是让它做什么，它就做什么。打印机可能被关掉了。网页可能临时性地不能浏览。在一个任务的处理过程中，硬件经常出现问题。例如，打印机在打印过程中可能没有纸了。 

3. 物理限制

   磁盘满了，可用存储空间已被用完。 

4. 代码错误
程序方法有可能无法正确执行。例如，方法可能返回了一个错误的答案，或者错误地调用了其他的方法。计算的数组索引不合法，试图在散列表中查找一个不存在的记录， 或者试图让一个空找执行弹出操作，这些都属于代码错误。 

对于方法中的一个错误，传统的做法是返回一个特殊的错误码， 由调用方法分析。例如，对于一个从文件中读取信息的方法来说，返回值通常不是标准字符，而是一个-1, 表示文件结束。这种处理方式对于很多异常状况都是可行的。还有一种表示错误状况的常用返回值是null引用。

遗憾的是，并不是在任何情况下都能够返回一个错误码。有可能无法明确地将有效数据与无效数据加以区分。一个返回整型的方法就不能简单地通过返回-1表示错误，因为-1很可能是一个完全合法的结果。 正如第5章中所叙述的那样，在Java中，如果某个方法不能够采用正常的途径完整它的 任务，就可以通过另外一个路径退出方法。在这种情况下，方法并不返回任何值， 而是抛出(throw) 一个封装了错误信息的对象。需要注意的是，这个方法将会立刻退出，并不返回任何值。此外，调用这个方法的代码也将无法继续执行，取而代之的是，异常处理机制开始搜索能够处理这种异常状况的异常处理器 (exception handler)。 异常具有自己的语法和特定的继承结构。下面首先介绍一下语法， 然后再给出有效地使用这种语言功能的技巧。

### 1.1 异常分类

在Java程序设计语言中，异常对象都是派生于Throwable类的一个实例。稍后还可以看 到，如果Java中内置的异常类不能够满足需求，用户可以创建自己的异常类。

图 7-1 是 Java 异常层次结构的一个简化示意图。

```
		Throwable
Error				Expception
			IOException		RuntimeException
```

需要注意的是，所有的异常都是由Throwable继承而来，但在下一层立即分解为两个分 支：Error和Exception

Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。 如果出现了这样的内部错误，除了通告给用户，并尽力使程序安全地终止之外，再也无能为力了。这种情况很少出现。 

在设计Java程序时，需要关注Exception层次结构。这个层次结构又分解为两个分支：一个分支派生于RuntimeException;另一个分支包含其他异常。划分两个分支的规则是：由程序错误导致的异常属于RuntimeException;而程序本身没有问题，但由于像I/O错误这类问题导致的异常属于其他异常:

派生于RuntimeException的异常包含下面几种情况： 

- 错误的类型转换。 
- 数组访问越界 
- 访问null指针 

不是派生于RuntimeException的异常包括： 

- 试图在文件尾部后面读取数据。
- 试图打开一个不存在的文件。 
- 试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在

“如果出现RuntimeException异常，那么就一定是你的问题”是一条相当有道理的规则。应该通过检测数组下标是否越界来避免ArraylndexOutOfBoundsException异常；应该通过在使用变量之前检测是否为null来杜绝NullPointerException异常的发生。

如何处理不存在的文件呢？难道不能先检查文件是否存在再打开它吗？嗯，这个文件有可能在你检查它是否存在之前就已经被删除了。因此，“是否存在”取决于环境，而不只是取决于你的代码。

Java语言规范将派生于Error类或RuntimeException类的所有异常称为非受查(unchecked)异常，所有其他的异常称为受查(checked)异常。这是两个很有用的术语，在 后面还会用到。编译器将核查是否为所有的受査异常提供了异常处理器。 

### 1.2 声明受查异常

如果遇到了无法处理的情况，那么Java的方法可以抛出一个异常。这个道理很简单：一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什么错误。例如， 一段读取文件的代码知道有可能读取的文件不存在，或者内容为空，因此，试图处理文件信息的代码就需要通知编译器可能会抛出IOException类的异常。

方法应该在其首部声明所有可能抛出的异常。这样可以从首部反映出这个方法可能抛出哪类受査异常。例如，下面是标准类库中提供的FilelnputStream类的一个构造器的声明（有 关输入和输出的更多信息请参看卷Ⅱ的第2章。）

```
public FilelnputStream(String name) throws FileNotFoundException
```

这个声明表示这个构造器将根据给定的String参数产生一个FilelnputStream对象，但也有可能抛出一个FileNotFoundException异常。如果发生了这种糟糕情况，构造器将不会初始化一个新的FileInputStream对象， 而是抛出一个FileNotFoundException类对象。 如果这个方法真的抛出了这样一个异常对象，运行时系统就会开始搜索异常处理器， 以便知道如何处理FileNotFoundException对象。

在自己编写方法时， 不必将所有可能抛出的异常都进行声明。至于什么时候需要在方法中用throws子句声明异常，什么异常必须使用throws子句声明，需要记住在遇到下面4种情况时应该抛出异常：

- 1)调用一个抛出受査异常的方法，例如，FilelnputStream构造器。 
- 2)程序运行过程中发现错误，并且利用throw语句抛出一个受查异常（下一节将详细地 介绍throw语句）。
- 3)程序出现错误，例如，a[-1]=0会抛出一个ArraylndexOutOffloundsException这样的 非受查异常。
- 4)Java 虚拟机和运行时库出现的内部错误。

如果出现前两种情况之一，则必须告诉调用这个方法的程序员有可能抛出异常。为什么？ 因为任何一个抛出异常的方法都有可能是一个死亡陷阱。如果没有处理器捕获这个异常，当前执行的线程就会结束。