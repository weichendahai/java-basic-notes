Java基础知识笔记-18-类加载机制与反射

## 1 类的加载，连接和初始化

### 1.1 JVM和类

当调用Java命令运行某个Java程序时，该命令将会启动一个Java虚拟机进程，不管该Java程序有多么复杂，当程序启动了多少个线程，他们都处于该Java虚拟机进程里。正如前面介绍的，同一个JVM的所有线程，所有变量都处于同一个进程里，他们都使用该JVM进程的内存区。当系统出现以下几种情况时，JVM进程将被终止。

- 程序运行到最后正常结束
- 程序运行到使用System.exit()或者Runtime.getRumtime().exit()代码处结束程序。
- 程序执行过程中遇到未捕获的异常或错误而结束
- 程序所在平台强制结束了JVM进程

下面以类的类变量来说明这个问题。下面程序先定义了一个包含类变量的类

```java
A.java
public class A
{
	//定义该类的类变量
	public static int a=6;
}
```

上面程序中的粗体字代码定义了一个类变量a，接下来定义一个类创建A类的实例，并访问A对象的类变量a

```java
ATest1.java
public class ATest1
{
	public static void main(String[] args)
	{
		//创建A类的实例
		A a=new A();
		//让a实例的类变量a的值自加
		a.a++;
		System.out.println(a.a);
	}
}
```

下面程序也创建A对象，并访问其类变量a的值

```java
ATest.java
public class ATest2
{
	public static void main(String[] args)
	{
		//创建A类的实例
		A b=new A();
		//输出b实例的类变量a的值
		System.out.println(b.a);
	}
}
```

两个结果第一个输出7第二个输出6，两次运行是两次运行JVM进程，第一次运行JVM结束后，他对A类所做的修改会全部丢失---第二次运行JVM会再次初始化A类

### 1.2 类的加载

当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三个步骤来对该类进行初始化。如果没有意外，JVM将连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或者类初始化。

类加载指的是将类的class文件读入内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象

类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者还可以通过继承ClassLoader基类来创建自己的类加载器。

通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。

- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件
- 通过网络加载class文件
- 把一个Java源文件动态编译，并执行加载

类加载器同城无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类

### 1.3 类的连接

当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中，类连接又分为如下三个阶段

- 验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致
- 准备：类准备阶段则负责为类的类变量分配内存，并设置默认初始值
- 解析：将类的二进制数据中的符号引用替换成直接引用

### 1.4 类的初始化

在类的初始化阶段，虚拟机负责对类进行初始化，主要就是对类变量进行初始化。在Java类中对类变量指定初始值有两种方式：①声明类变量指定初始值；②使用静态初始化块为类变量指定初始值。例如下面代码片段。

```java
public class Test
{
	//声明变量a时指定初始值
	static int a=5;
	static int b;
	static int c;
	static{
		//使用静态初始化块为变量b指定初始值
		b=6;
	}
	...
}
```

对于上面代码，程序为类变量a，b都显式指定了初始值，5，6，但是类变量c则没有指定初始值，他将采用默认初始值0。

声明变量时指定初始值，静态初始化块都将被当成类的初始化语句，JVM会按这些语句在程序中的顺序依次执行它们，例如下面的类。

```java
Test.java
public class Test
{
	static 
	{
		//使用静态初始化块为变量b指定初始值
		b=6;
		System.out.println("--------");
	}
	//声明变量a时指定初始值
	static int a=5;
	static int b=9;
	static int c;
	public static void main(String[] args){
		System.out.println(Test.b);
}
}
```

上面的代码先在静态初始化块中为b变量赋值，此时类变量b的值为6；接着程序向下执行，直到程序再次为变量b赋值。最后变量b的值为9。

JVM初始化一个类包含如下几个步骤

1. 假如这个类还没有被加载和连接，则程序先加载并连接该类
2. 假如该类的直接父类还没有被初始化，则先初始化其直接父类
3. 假如类中有初始化语句，则系统依次执行这些初始化语句

当执行第2个步骤时，系统对直接父类的初始化步骤也遵循1-3，如果又有直接父类，再重复1-3步骤，确保要使用类的所有父类（直接父类或者间接父类）都被初始化。

### 1.5 类初始化的时机

当Java程序首次通过下面6种方式来使用某个类或接口时，系统就会初始化该类或接口

- 创建类的实例。为某个类创建实例的方法包括：使用new操作符来创建实例，通过反射来创建实例，通过反序列化的方式来创建实例
- 调用某个类的类方法（静态方法）
- 访问某个类或接口的类变量，或者为该类变量赋值
- 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象
- 初始化某个类的子类。
- 直接使用java.exe命令来运行某个主类。当运行某个主类时，程序会先初始化该主类

除此之外，下面的几种情形需要特别指出

对于一个final型的类变量，如果该类变量的值在编译时就可以确定下来，那么这个类变量相当于“宏变量”。Java编译器会在编译时直接把这个类变量出现的地方替换成它的值，因此即使程序使用该静态类变量，也不会导致类的初始化。如下示例程序

```java
class MyTest
{
	static
	{
		System.out.println("静态初始化块...");
	}
	//使用一个字符串直接量为static final的类变量赋值
	static final String compileConstant="疯狂Java讲义";
}
public class CompileConstantTest
{
	public static void main(String[] args)
	{
		//访问，输出MyTest中的compileConstant类变量
		System.out.println(MyTest.compileConstant); //①
	}
}
```

上面程序的MyTest类章有一个compileConstant的类变量，该变量使用了final修饰，而且它的值可以在编译时确定下来，因此compileConstant会被当成“宏变量”处理。程序中所有使用compileConstant的地方都会被直接替换成它的值---也就是说，上面程序中①处的代码在编译时就会被替换成“疯狂Java讲义”，所有①行代码不会导致初始化MyTest类。

反之，如果final修饰的类变量不能在编译时确定下来，则必须等到运行时才可以确定该类变量的值，如果通过该类来访问它的类变量，就会导致该类被初始化。例如将上面程序中定义compileConstant的代码改为如下

```java
//采用系统当前时间为static final类变量赋值
static final String compileConstant=System.currentTimeMills()+"";
```

因为上面定义的cimpileConstant类变量的值必须在运行时才可以确定，所以①处的粗体字代码必须保留对MyTest类的类变量的引用，这行代码就变成了使用MyTest的类变量，这将导致MyTest类被初始化。

当使用ClassLoader类的loadClass()方法来加载某个类时，该方法只是加载该类，并不会执行该类的初始化。使用Class的forName()静态方法才会导致强制初始化该类。

