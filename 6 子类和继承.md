# 1子类与父类
继承是一种由已创建的类创建新类的机制，利用继承，我们先创建一个共有属性的一般类，根据一般类再创建具有特殊属性的新类，新类继承一般类的状态和行为，并根据需要增加他自己新的状态和行为，由继承得到的类称为子类，被继承的称为父类。  
Java中，一个子类只能继承一个父类，不支持多重继承；  
格式如下：
```
class Student extends People{
…
}
```
# 2 子类的继承性
一个子类继承的成员变量应当是这个类的完全成员。
## 2.1子类和父类在同一包中的继承性
如果子类和父类在同一包中，那么，子类自然继承了其父类中不是private的成员变量作为自己的成员变量，并且也自然的继承了父类中不是private的方法作为自己的方法，继承的成员和方法的访问权限保持不变。
## 2.2子类和父类不在同一包中的继承
子类只继承父类中protected和public访问权限的成员变量和方法作为继承；
# 3 成员变量的隐藏和方法重写
## 3.1成员变量的隐藏
在编写子类时，我们任然可以声明成员变量，一种特殊的情况是，如果声明的成员变量的成员变量的名字和从父亲继承来的成员变量的名字相同（声明的类型可以不同），在这种情况下，子类就会隐藏掉继承的成员变量，即子类对象及子类自己定义的方法操作与父类同名的成员变量是指子类重新声明的这个成员变量。需要注意的是，子类对象任然可以调用子类继承的方法操作隐藏的成员变量；
## 3.2方法重写
### 1.重写的语法规则
如果子类可以继承父类的某个实例方法，那么子类就有权利重写这个方法。  

方法重写是指：子类中定义一个方法，这个方法的类型和父类的方法的类型一致或者是父类的方法的类型的子类型（所谓子类型是指，如果父类的方法的类型是“类”，那么允许子类的重写方法的类型是“子类”）一致，并且这个方法的名字，参数个数，参数的类型和父类的方法完全相同。子类如此定义的方法称作子类重写的方法。
### 2.重写的目的
子类通过方法的重写可以隐藏继承的方法，子类通过方法的重写可以把父类的状态和行为改变为自身的状态和行为。  

如果父类的方法f()可以被子类继承，子类就有权利重写f()，一旦子类重写了父类的方法f()，就隐藏了继承的方法f()，那么子类对象调用方法f()一定是调用的重写方法f()；如果子类没有重写，而是继承了父类的方法f()，那么子类创建的对象当然可以调用f()方法，只不过方法f()产生的行为和父类的相同而已。  

重写方法即可以操作继承的成员变量，调用继承的方法，也可以操作子类新声明的成员变量，调用新定义的其他方法，但无法操作被子类隐藏的方法，如果子类想使用被隐藏的方法或成员变量，必须使用关键字super。
例：
```
class University{
	void enterRule(double math,double english,double chinese){
		double total=math+english+chinese;
		if(total>=200){
			System.out.println("OK");
		else
			System.out.println("No");
		}
	}
}
class ImportantUniversity extend University{
	void enterRule(double math,double english,double chinese){
		double total=math+english+chinese;
		if(total>=245){
			System.out.println("Ok");
		else
			System.out.println("No");
		}
	}
}
public class exercise{
	public static void main(String args[]){
		double math=64,english=76.5,chinese=66;
		ImportantUniversity univer=new ImportantUniversity();
		univer.enterRule(math,english,chinese);
		math=89;
		english=80;
		chinese=86;
		univer=new ImportantUniversity();
		univer.enterRule(math,english,chinese);
	}
}
```
例：
```
class A{
	float computer(float x,floaty){
		return x+y;
	}
	public int g(int x,int y){
		return x+y;
	}
}

class B extends A{
	float computer(float x,floaty){
		return x*y;
	}
}
public class exercise{
	public static void main(String args[]){
		B b=new B();
		double result=b.computer(8,9);
		System.out.println("调用重写的方法得到的结果是:"+result);
		int m=b.g(12,8);
		System.out.println("调用继承的方法得到的结果是:"+m);
	}
}
```
但是如果子类重写方法时如下就会出现错误：
```
double computer(float x,float y){
	return x*y;
}
```
原因是子类重写的方法和父类的方法类型不一致，这样子类就无法隐藏继承的方法，导致子类出现两个方法的名字相同，参数也相同的情况，这是不允许的（见上一章第七节）
### 3.重写的注意事项
重写父类的方法时，不可以降低方法的访问权限；

# 4 super关键字
## 4.1用super操作被隐藏的的成员变量和方法
子类一旦隐藏了继承的成员变量，那么子类创建的对象就不再拥有该变量，该变量将归关键字super所有，同样子类一旦隐藏了继承的方法，那么子类创建的对象就不能调用被隐藏的方法，该方法的调用由关键字super负责。  
因此，如果在子类中想使用被子类隐藏的成员变量或方法就需要使用关键字super。
```
class Bank {
	int saveMoney;
	int year;
	double interest;
	public double computerInterest() {
		interest=year*0.035*saveMoney;
		System.out.printf("%d元存在银行%d年的利率是%f元\n",saveMoney,year,interest);
		return interest;
		}
}

class ConstructionBank extends Bank{
	double year;
	public double computerInterest() {
		super.year=(int)year;
		double remainNumber=year-(int)year;
		int day=(int)(remainNumber*1000);
		interest=super.computerInterest()+day*0.0001*saveMoney;
		System.out.printf("%d元存在建设银行%d年%d天的利率是",saveMoney,super.year,day,interest);
		return interest;
	}
}

class BankOfDalian extends Bank{
	double year;
	public double computerInterest() {
		super.year=(int)year;
		double remainNumber=year-(int)year;
		int day=(int)(remainNumber*1000);
		interest=super.computerInterest()+day*0.00012*saveMoney;
		System.out.printf("%d元存在大连银行%d年%d天的利率是",saveMoney,super.year,day,interest);
		return interest;
	}
}

public class exercise{
	public static void main(String args[]) {
		int amount=5000;
		ConstructionBank bank1=new ConstructionBank();
		bank1.saveMoney=amount;
		bank1.year=5.216;
		double interest1=bank1.computerInterest();
		BankOfDalian bank2=new BankOfDalian();
		bank2.saveMoney=amount;
		bank2.year=5.216;
		double interest2=bank2.computerInterest();
		System.out.printf("两个银行利息相差%f元", interest1-interest2);
		
	}
}
```
运行结果：
```
```

## 4.2使用super调用父类的构造方法
使用子类的构造方法创建一个子类的对象时，子类的构造方法总是先调用父类的某个构造方法，也就是说，如果子类的构造方法没有明显的指明使用父类的哪个构造方法，子类就调用父类的不带参数的构造方法。  

由于子类不继承父类的构造方法，因此，子类在其构造方法中需使用super来调用父类的构造方法，而且super必须是子类构造方法中的头一条语句，即如果在子类的构造方法中，没有明显写出super关键字来调用父类的某个构造方法，那么默认有：
```
super();
```
例如：
```
class Student{
	int number;String name;
	Student(){
		
	}
	Student(int number,String name){
		this.number=number;
		this.name=name;
		System.out.println("我的名字是："+name+"学号是："+number);
	}
}
class UniverStudent extends Student{
	boolean 婚否;
	UniverStudent(int number,String name,boolean b){
		super(number,name);
		婚否=b;
		System.out.println("婚否="+婚否);
	}
}
public class exercise{
	public static void main(String args[]){
		UniverStudent zhang=new UniverStudent(9901,"何晓玲",false);
	}
}
```
如果在类里定义了一个或多个构造方法，那么Java不提供默认的构造方法（不带参数的构造方法），因此，当我们在父类中定义多个构造方法时，应当包括一个不带任何参数的构造方法（如上面代码中的Student类），以防出现省略super时出现错误。

# 5 final关键字
final关键字可以修饰类，成员变量和方法中的局部变量。
## 5.1 final类
可以使用final将类声明为final类，该类不能被继承，即不能有子类。
```
final class A{
}
```
## 5.2final方法
如果用final修饰父类中的一个方法，那么这个方法不允许被子类重写，也就是说，不允许子类隐藏可以继承的final方法。
## 5.3常量
如果成员变量或局部变量被final修饰，那么就是常量。

# 6对象的上转型对象
假设，A是B的父类，当用子类创建一个对象，并把这个对象的引用放到父类的对象中时，例如;
```
A a;
a=new B();
```
或者：
```
A a;
B b=new B();
a=b;
```
这时，称对象a是对象b的上传型对象

```
graph LR
对象-->新增的变量
对象-->新增的方法
对象-->继承或隐藏的变量
对象-->继承或重写的方法
对象的上传型对象-->继承或隐藏的变量
对象的上传型对象-->继承或重写的方法
```
##### 1.上传型对象不能操作子类新增的成员变量（失去了这部分属性）；不能调用子类新增的方法（失去了一些功能）；
##### 2.上传型对象可以访问子类继承或隐藏的成员变量，也可以调用子类继承的方法或子类重写的实例方法。
上传型对象操作子类继承的方法或子类重写的实例方法，其作用等价于子类对象去调用这些方法。因此，如果子类重写了父类的某个实例方法后，当对象的上传型对象调用这个实例方法时一定调用了子类重写的实例方法。  
注意：
1.不要将父类创建的对象和子类对象的上传型对象混淆。  
2.可以将对象的上传型对象在强制转换到一个子类对象，这时，该子类对象又具备了子类所有属性和功能。  
3.不能将父类创建的对象的引用赋值给子类声明的对象  
```
class leirenyuan{//类人猿
	void crySpeak(String s){
		System.out.println(s);
	}
}
class People extends Leirenyuan{
	void computer(int a,int b){
		int c=a*b;
		System.out.println(c);
	}
	void crySpeak(String s){
		System.out.println("***"+s+"***");
	}
}
public class exercise{
	public static void main(String args[]){
		Leirenyuan monkey=new People();
		monkey.crySpeak("I love this game");
		People people=(People)monkey;
		people.computer(10,10);
	}
}
//***I love this game***
//100
```
这是因为monkey调用的是子类重写的方法crySpeak，需要注意的是:
```
monkey.computer(10,10);
```
是错误的，因为computer方法是子类新增的方法。  

注意：如果子类重写了父类的静态方法，那么子类对象的上传型对象不能调用子类重写的静态方法，只能调用父类的静态方法。
# 7继承与多态
当一个类有很多子类时，并且这些子类都重写了父类中的某个方法。那么当我们把子类创建的对象的引用都放到一个父类的对象中，就得到了该对象的一个上传型对象，那么这个上传型对象在调用这个方法时就可能具有多种形态，因为不同的子类在重写父类的方法时可能产生不同的行为。
```
class Animal{
	void cry(){
	}
}

class Dog extends Animal(){
	void cry(){
		System.out.println("wangwang");
	}
}
class Cat extends Animal(){
	void cry(){
		System.out.println("miaomiao");
	}
}

public class exercise{
	public static void main(String args{]){
		Animal animal;
		animal=new Dog();
		animal.cry();
		animal=new Cat();
		animal.cry();
	}
}
```
多态性就是指父类中的某个方法被其子类重写时，可以各自产生自己的功能行为。
# 8 abstract类和abstract方法
用关键字abstract修饰的类称为abstract类（抽象类）  
如：
```
abstract class A{
}
```
用关键字abstract修饰的方法称为abstract方法（抽象方法），例如
```
abstract int min(int x,int y);
```
对于abstract方法，只允许声明，不允许实现（没有方法体），而且不允许使用abstract和final同时修饰一个方法和类。
##### 1.abstract类中可以有abstract方法
##### 2.abstract类不能用new运算符创建对象
如果一个非抽象类是某个抽象类的子类，那么它必须重写父类的抽象方法，给出方法体，这就是为什么不允许使用final和abstract同时修饰一个方法或类的原因。 

注意：abstract类也可以没有abstract方法。  
如果一个abstract类是abstract类的子类，它可以重写父类的abstract方法，也可以继承这个abstract方法。
# 9面向抽象编程
在设计一个系统时，可以通过abstract类中声明若干个abstract方法，表明这些方法在整个系统设计中的重要性，方法体的内容细节由它的非abstract子类去完成。  
例如:
```
abstract class Geometry{
	public abstract double getArea();
}
```
Pillar类的设计者可以面向Geometry类编写代码，即Pillar类应当把Geometry对象当作自己的成员，该成员可以调用Geometry的子类重写getArea()方法，这样，Pillar类就可以将计算底面积的任务指派给Geometry类的子类的实例；  

以下pillar类的设计不再依赖具体类，而是面向Geometry类，即Pillar类中的bottom对象是抽象类Geometry声明的对象，而不是具体类声明的对象，重新设计的pillar类的代码如下：
```
class Pillar{//柱体
	Geometry bottom;
	double height;
	Pillar(Geometry bottom,double height){
		this.bottom=bottom;
		this.height=height;
	}
	public double getVolume() {
		return bottom.getArea()*height;
	}
}

class Circle extends Geometry{//圆底柱体
	double r;
	Circle(double r){
		this.r=r;
	}
	public double getArea() {
		return(3.14*r*r);
	}
}

class Rectangle extends Geometry{//矩形底柱体
	double a,b;
	Rectangle(double a,double b){
		this.a=a;
		this.b=b;
	}
	public double getArea() {
		return a*b;
	}
}

public class exercise{
	public static void main(String args[]) {
		Pillar pillar;
		Geometry bottom;
		bottom=new Rectangle(12,22);
		pillar=new Pillar(bottom,58);
		System.out.println("矩形底柱体的体积是："+pillar.getVolume());
		bottom=new Circle(10);
		pillar=new Pillar(bottom,58);
		System.out.println("圆底柱体的体积是："+pillar.getVolume());
	}
}
```
